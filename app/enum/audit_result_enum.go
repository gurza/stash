// Code generated by enum generator; DO NOT EDIT.
package enum

import (
	"fmt"
	"strings"
)

// AuditResult is the exported type for the enum
type AuditResult struct {
	name  string
	value int
}

func (e AuditResult) String() string { return e.name }

// Index returns the underlying integer value
func (e AuditResult) Index() int { return e.value }

// MarshalText implements encoding.TextMarshaler
func (e AuditResult) MarshalText() ([]byte, error) {
	return []byte(e.name), nil
}

// UnmarshalText implements encoding.TextUnmarshaler
func (e *AuditResult) UnmarshalText(text []byte) error {
	var err error
	*e, err = ParseAuditResult(string(text))
	return err
}

// _auditResultParseMap is used for efficient string to enum conversion
var _auditResultParseMap = map[string]AuditResult{
	"success":   AuditResultSuccess,
	"denied":    AuditResultDenied,
	"notfound":  AuditResultNotFound,
	"not_found": AuditResultNotFound,
}

// ParseAuditResult converts string to auditResult enum value.
// Parsing is always case-insensitive.
func ParseAuditResult(v string) (AuditResult, error) {
	if val, ok := _auditResultParseMap[strings.ToLower(v)]; ok {
		return val, nil
	}
	return AuditResult{}, fmt.Errorf("invalid auditResult: %s", v)
}

// MustAuditResult is like ParseAuditResult but panics if string is invalid
func MustAuditResult(v string) AuditResult {
	r, err := ParseAuditResult(v)
	if err != nil {
		panic(err)
	}
	return r
}

// Public constants for auditResult values
var (
	AuditResultSuccess  = AuditResult{name: "success", value: 0}
	AuditResultDenied   = AuditResult{name: "denied", value: 1}
	AuditResultNotFound = AuditResult{name: "notfound", value: 2}
)

// AuditResultValues contains all possible enum values
var AuditResultValues = []AuditResult{
	AuditResultSuccess,
	AuditResultDenied,
	AuditResultNotFound,
}

// AuditResultNames contains all possible enum names
var AuditResultNames = []string{
	"success",
	"denied",
	"notfound",
}

// AuditResultIter returns a function compatible with Go 1.23's range-over-func syntax.
// It yields all AuditResult values in declaration order. Example:
//
//	for v := range AuditResultIter() {
//	    // use v
//	}
func AuditResultIter() func(yield func(AuditResult) bool) {
	return func(yield func(AuditResult) bool) {
		for _, v := range AuditResultValues {
			if !yield(v) {
				break
			}
		}
	}
}

// These variables are used to prevent the compiler from reporting unused errors
// for the original enum constants. They are intentionally placed in a var block
// that is compiled away by the Go compiler.
var _ = func() bool {
	var _ auditResult = auditResult(0)
	// This avoids "defined but not used" linter error for auditResultSuccess
	var _ auditResult = auditResultSuccess
	// This avoids "defined but not used" linter error for auditResultDenied
	var _ auditResult = auditResultDenied
	// This avoids "defined but not used" linter error for auditResultNotFound
	var _ auditResult = auditResultNotFound
	return true
}()
