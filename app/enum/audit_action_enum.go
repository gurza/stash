// Code generated by enum generator; DO NOT EDIT.
package enum

import (
	"fmt"
	"strings"
)

// AuditAction is the exported type for the enum
type AuditAction struct {
	name  string
	value int
}

func (e AuditAction) String() string { return e.name }

// Index returns the underlying integer value
func (e AuditAction) Index() int { return e.value }

// MarshalText implements encoding.TextMarshaler
func (e AuditAction) MarshalText() ([]byte, error) {
	return []byte(e.name), nil
}

// UnmarshalText implements encoding.TextUnmarshaler
func (e *AuditAction) UnmarshalText(text []byte) error {
	var err error
	*e, err = ParseAuditAction(string(text))
	return err
}

// _auditActionParseMap is used for efficient string to enum conversion
var _auditActionParseMap = map[string]AuditAction{
	"read":   AuditActionRead,
	"create": AuditActionCreate,
	"update": AuditActionUpdate,
	"delete": AuditActionDelete,
}

// ParseAuditAction converts string to auditAction enum value.
// Parsing is always case-insensitive.
func ParseAuditAction(v string) (AuditAction, error) {
	if val, ok := _auditActionParseMap[strings.ToLower(v)]; ok {
		return val, nil
	}
	return AuditAction{}, fmt.Errorf("invalid auditAction: %s", v)
}

// MustAuditAction is like ParseAuditAction but panics if string is invalid
func MustAuditAction(v string) AuditAction {
	r, err := ParseAuditAction(v)
	if err != nil {
		panic(err)
	}
	return r
}

// Public constants for auditAction values
var (
	AuditActionRead   = AuditAction{name: "read", value: 0}
	AuditActionCreate = AuditAction{name: "create", value: 1}
	AuditActionUpdate = AuditAction{name: "update", value: 2}
	AuditActionDelete = AuditAction{name: "delete", value: 3}
)

// AuditActionValues contains all possible enum values
var AuditActionValues = []AuditAction{
	AuditActionRead,
	AuditActionCreate,
	AuditActionUpdate,
	AuditActionDelete,
}

// AuditActionNames contains all possible enum names
var AuditActionNames = []string{
	"read",
	"create",
	"update",
	"delete",
}

// AuditActionIter returns a function compatible with Go 1.23's range-over-func syntax.
// It yields all AuditAction values in declaration order. Example:
//
//	for v := range AuditActionIter() {
//	    // use v
//	}
func AuditActionIter() func(yield func(AuditAction) bool) {
	return func(yield func(AuditAction) bool) {
		for _, v := range AuditActionValues {
			if !yield(v) {
				break
			}
		}
	}
}

// These variables are used to prevent the compiler from reporting unused errors
// for the original enum constants. They are intentionally placed in a var block
// that is compiled away by the Go compiler.
var _ = func() bool {
	var _ auditAction = auditAction(0)
	// This avoids "defined but not used" linter error for auditActionRead
	var _ auditAction = auditActionRead
	// This avoids "defined but not used" linter error for auditActionCreate
	var _ auditAction = auditActionCreate
	// This avoids "defined but not used" linter error for auditActionUpdate
	var _ auditAction = auditActionUpdate
	// This avoids "defined but not used" linter error for auditActionDelete
	var _ auditAction = auditActionDelete
	return true
}()
